#KMP  <<<  The first 4 characters '#KMP' are the magic for a KMP text file.
#     <<<  Don't remove them!
#
###############################################################################
#
# This is a textual representation of a KMP file used in Nintendos "Mario Kart
# Wii". "Wiimms SZS Tools" can convert binary (raw) and text KMP files in both
# directions. The text parser supports variables, C like expressions and nested
# IF-THEN-ELSE and LOOP structures.
#
# Info about the general parser syntax and semantics:
#   * https://szs.wiimm.de/doc/syntax
#
# Info about the KMP text syntax and semantics:
#   * https://szs.wiimm.de/doc/kmp/syntax
#
# Reference list of KMP parser functions:
#   * https://szs.wiimm.de/doc/kmp/func
#
# Info about the KMP file format:
#   * https://szs.wiimm.de/r/wiki/KMP
#
# Hint:
#   Set one of the options --no-header (-H) or --brief (-B) while decoding
#   to suppress this general description. The --brief option will also disable
#   info parts in the different sections. If --brief is set twice, the output
#   of the unneded sections CKPH, ENPH and ITPH is completly suppressed.
#

#
###############################################################################

[SETUP]
# This is the general setup and info section. Some parameters are preceeded by
# a hash ('#') to signal the informative only status. This section should
# always be the first one.

# Identify the tool and version, that have written this file:
TOOL     = ?
SYSTEM   = cygwin64
VERSION  = 2.26a
REVISION = 8462
DATE     = 2021-05-08

# If the following info string is not empty it will be
# inserted at the end of the KMP file behind all sections:
INFO = ""

# KMP version (offset 0x0c):
KMP-VERSION = 2520

# If set to '1', objects with road features will be added to the internal KCL
# for the automatic height calculations. Like --kcl +add-road
KCL-FALL-ADD-ROAD = 0

# Define the battle mode for the next text output:
#  0 : Disable battle support
#  1 : Enable battle support
#  2 : Enable exclusive battle support => remove unneeded sections and parameters
# This setting is overiden by option --battle.
BATTLE-MODE = 0

# Experimental feature in progress!
# If set to 1, an additional KMP section named »WIM0« is created. This new
# section should contain data of this text file like names or flags, that can
# be restored later. At the moment, the new section contains only dummy data
# for compatibility tests with other tools and the Wii. Option --wim0 can
# override this setting.
KMP-WIM0 = 0

# Statistics: Entry counter for each section:
 # N-AREA =    10
 # N-CAME =    16
 # N-CKPH =     1
 # N-CKPT =    34
 # N-CNPT =     0
 # N-ENPH =     7
 # N-ENPT =    39
 # N-GOBJ =    24
 # N-ITPH =    10
 # N-ITPT =    45
 # N-JGPT =    29
 # N-KTPT =     1
 # N-MSPT =     0
 # N-POTI =    18,  150
 # N-STGI =     1

#------------------------------------------------------------------------------

# These are the default settings for route objects:
# @ROUTE-OBJECT       = o$obakeblockSFCc
# @ROUTE-OBJECT-SHIFT = v( 0.00, 0.00, 0.00 )
# @ROUTE-OBJECT-SCALE = v( 0.20, 0.40, 1.00 )


#
###############################################################################

# This second part of section [SETUP] is an example to prepare a KMP source
# file for conditional encoding (compiling). The idea is, that the user
# defines variables with the "--const name=value" option while calling one of
# the tools 'wszst' or 'wkmpt' to create different KMP files.
#
# Set option --no-param (-P) to disable this parameter part.
#
# This example scans 7 parameters. All variables are not special for the KMP
# encoder and fully under user control: The user can remove or rename them or
# can add more parameters. But this values have predefined meanings:
#
#   slot   : Create a KMP for the entered slot.
#            The default value 0 means: Design for allmost all slots.
#            Use it with @if..@else..@endif to support special slots.
#
#   d      : Create a KMP file for a "_d" variant of a track.
#            Use it with @if..@else..@endif to skip objects.
#
#   arena  : If >0, then create a battle arena instead of a racing track.
#
#   test   : If  >0, then test mode is enabled.
#            If <=0, test mode and also all parameters below are disabled.
#
#   ocam   : If >0 and also test>0, then enable test of opening camera #
#            (endless looping until button 'A' is pressed). With the default
#            value 0 all opening scenes are looped. If test mode is disabled,
#            the cameras work as usual.
#
#   showrt : If set and also test>0, points of different sections ar shown as
#            item boxes and all standard item boxes are disabled. Set one or more
#            of the following bits to show the points of the section:
#              1 : ENPT
#              2 : ITPT
#              4 : JGPT
#              8 : CNPT
#             16 : MSPT
#             32 : POTI
#             -1 : enable all section (all bits set!)
#
#   showck : If set and also test>0, show check points as trees (or other
#            user defined objects). See section [CKPT] for details.
#
#   laps   : It controls the number of laps by changing the settinge of the
#            check point modes (CKPT/@AUTO-MODE). Allowed values are:
#              0: Make the race a short as possible.
#              1: Finish the race after 1 lap
#              3: Finish the race after 3 laps (default).
#              4: Never finish the race (unlimited).
#            Value 3 is used, if test mode is disabled.
#

# First we define default values (if not set by --const) for all parameters:

  @def slot	?= 0	# Enable support for special slots
  @def d	?= 0	# Enable support for _d files
  @def arena	?= 0	# Enable battle arena support and allow different modes
  @def test	?= 0	# Enable test mode
  @def ocam	?= 0	# Test opening cam, only relevant if test>0
  @def showrt   ?= 0    # Show item boxes for route points.
			# Only relevant if test>0. Set bit combination:
			#   1:ENPT, 2:ITPT, 4:JGPT, 8:CNPT, 0x10:MSPT, 0x20:POTI (-1:all)
  @def showck   ?= 0    # Show objects a check point positions if test>0.
			#   0:off, 1:mandatory, 2:all, 3=left+right
  @def laps	?= 3	# Number of laps (0|1|3|4), only relevant if test>0

# In a second step, global mode variables are defined and normalized.
# All conditions in this file should use these variables.

  @gdef mode$slot	= slot > 0 ? slot : 0
  @gdef mode$d		= d > 0
  @gdef mode$arena	= arena > 0 ? arena : 0

  @gdef mode$test	= test > 0 ? test : 0
  @gdef mode$ocam	= mode$test && ocam >= 1 ? ocam : 0
  @gdef mode$laps	= mode$test && laps >= 0 ? laps : 3
  @gdef mode$showrt	= mode$test ? showrt : 0
  @gdef mode$showck	= mode$test ? showck : 0
  @gdef mode$automode	= select(mode$laps,AM$SHORT,AM$1LAP,AM$OFF,AM$OFF,AM$UNLIMIT)

# Now the tools 'wszst' and 'wkmpt' can be called with the --const (or short
# -c) option for a conditional encoding. Example:
#	-c test=12,ocam=2,laps=0
# Enable test mode 12, show opening camera 2 endless (until pressing A) and
# finish the race very fast to view the finish cameras very soon.

#
###############################################################################
# Macros

@macro itembox
    #-------------------------------------------------------------------
    # This macro helps to place N itemboxes in a row between
    # 2 points with optimal height.
    #-------------------------------------------------------------------
    # Syntax:
    #	@:ITEMBOX(fall,1,pos1)
    #	@:ITEMBOX(fall,n,pos1,pos2)
    #	@:ITEMBOX(fall,n,pos1,pos2,factor)
    #	@:ITEMBOX(fall,n,pos1,pos2,factor,second)
    #	@:ITEMBOX(fall,n,pos1,pos2,factor,second,itemtype)
    #-------------------------------------------------------------------
    # Parameters:
    #	FALL	: If >0: Raise the box by FALL and let it fall to
    #		: the road to get the optimal height.
    #	N	: If >0: Create N itemboxes between POS1 and POS2.
    #	POS1	: Position of first itembox.
    #	POS2	: Position of last itembox.
    #	FACTOR	: If set and >0.01: Create a line from POS1 to POS2.
    #		: Enlarge the line by FACTOR in both directions.
    #		: Then use the new points as new POS1 and POS2.
    #   SECOND	: If set and >0: Move each second itembox into a second
    #		: row. The distance between both rows is SECOND units.
    #   ITEMTYPE: Use this value for player and enemy items.
    #-------------------------------------------------------------------
    # Examples:
    #	@:itembox( 200, 1, point )
    #	@:itembox(   0, 3, point1, point2, 0.9 )
    #	@:itembox( 500, 8, point1, point2, 1, 250, ITEM$3GREEN )
    #	@:itembox( 200, 4, v(2000,1000,3000), v(3000,1000,5000) )
    #-------------------------------------------------------------------

    @param fall n p1 p2 factor second itemtype
    @pdef fall = fall > 0 ? fall : 0
    @if isScalar(factor) && factor > 0.01
	@pdef a = p1, b = p2, f = (1.0-factor)/2
	@pdef p1 = pos(f,a,b)
	@pdef p2 = pos(f,b,a)
    @endif
    @pdef itemtype = int(itemtype)
    @if n == 1
	@pdef p = fall ? kcl$fall(p1+vy(fall),200,KCL$DRIVE) : p1
	0 o$itembox p 0 itemtype itemtype 0 -1  0 v3(0) 0 0 0 0 0x3f  v3(1)
    @else
	@pdef second = isScalar(second) && second > 0
		> ? hrot(vz(second),hdir(p1,p2)+90) : v3(0)
	@pdef n = n - 1.0
	@for i=0;n
	    @pdef p = pos(i/n,p1,p2)
	    @doif(i&1)  @pdef p = p + second
	    @doif(fall) @pdef p = kcl$fall(p+vy(fall),200,KCL$DRIVE)
	    0 o$itembox p 0 itemtype itemtype 0 -1  0 v3(0) 0 0 0 0 0x3f  v3(1)
	@endfor
    @endif
@endmacro

#
